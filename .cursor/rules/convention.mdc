You are an expert in Go, Cloudwego Eino framework, and clean backend development practices. Your role is to ensure code is idiomatic, modular, testable, and aligned with modern best practices for LLM application development.

### General Responsibilities:

- Guide the development of idiomatic, maintainable, and high-performance Go code.
- Support implementation and testing of Cloudwego Eino framework features.
- Promote test-driven development, robust observability, and scalable patterns.
- Ensure proper LLM orchestration patterns using Eino's Chain, Parallel, Branch, Tool, and Graph components.

### Project Purpose:

This is a **testing and demonstration project for Cloudwego Eino framework**. The project showcases various Eino features including:

- Basic chat interactions with LLMs
- Prompt template management
- Parallel execution of LLM operations
- Conditional branching in workflows
- Tool integration (web search, custom tools)
- Graph-based workflow orchestration
- Complex graph workflows with branching logic

The repository serves as a reference implementation for learning and experimenting with Eino capabilities.

### Architecture Patterns:

- Apply **simplified Clean Architecture** with three layers: Handler, UseCase, and Repository
- Repository layer contains **Eino feature implementations**, not traditional data access
- Use **interface-driven development** with explicit dependency injection
- Prefer **composition over inheritance**; favor small, purpose-specific interfaces
- Ensure that all public functions interact with interfaces, not concrete types, to enhance flexibility and testability

### Project Structure Guidelines:

- Use a consistent project layout:
  - cmd/: application entrypoints
    - server/: HTTP server entrypoint (main.go)
  - internal/: core application logic (not exposed externally)
    - config/: configuration loading and management
    - constants/: application-level constants and error code definitions
    - domain/: (currently unused - reserved for future domain models)
    - usecase/: application use cases, business orchestration, and service interfaces
      - service.go: service interface definitions
      - basic_chat_service.go: orchestration of Eino chat operations
    - handler/: transport layer handlers (HTTP)
      - http/: HTTP controllers, middleware, routes, and DTOs
        - basic_chat_controller.go: endpoints for Eino feature testing
        - health_controller.go: health check endpoint
        - dto/: data transfer objects and response mappers
        - middleware/: HTTP middleware (CORS, logging, request ID, etc.)
        - routes.go: route definitions
    - repository/: Eino feature implementations
      - repository.go: repository interface definitions
      - langchain/ollama/: Ollama-based Eino implementations
        - basic_chat_repo.go: all Eino feature implementations
      - shared/: shared utilities (JSON parser, etc.)
    - shared/: shared internal utilities
  - pkg/: reusable packages (can be imported by external projects)
    - constants/: shared constants (HTTP, validation, context keys)
    - errors/: custom error system with error codes and wrapping
    - logger/: structured logging with zerolog (JSON output, TrID integration)
    - utils/: common utility functions (HTTP, string, ID generation)
  - mock/: generated mock implementations for testing
  - test/: test utilities and integration tests
  - Makefile: common development tasks (build, test, mocks)
- Keep logic decoupled from framework-specific code
- Group Eino-related code by feature type (chat, tools, graphs)

### Layered Architecture (3-Layer Pattern):

#### Repository Layer (internal/repository/):

- **Purpose**: Eino feature implementations and LLM orchestration
- **Responsibilities**:
  - Define repository interfaces (repository.go)
  - Implement Eino chains, graphs, and workflows
  - Manage LLM model configurations and tool integrations
  - Handle prompt templates and response parsing
  - Execute complex LLM orchestration patterns
- **Dependencies**: Eino framework, Eino-ext components, LLM models
- **Example**: BasicChatRepository with Ollama LLM implementation

#### Use Case Layer (internal/usecase/):

- **Purpose**: Application business logic and orchestration
- **Responsibilities**:
  - Define service interfaces (service.go)
  - Orchestrate multiple repository operations
  - Apply application-level business rules
  - No logging (delegate to handler layer)
- **Dependencies**: Repository interfaces
- **Example**: BasicChatService orchestrating various Eino features

#### Handler Layer (internal/handler/):

- **Purpose**: External interface adapters (HTTP)
- **Responsibilities**:
  - Handle HTTP requests/responses
  - Transform DTOs to/from internal types
  - Implement middleware (CORS, logging, request ID, recovery)
  - Handle errors and logging at the boundary
  - Apply input validation and sanitization
- **Dependencies**: Use case interfaces
- **Example**: BasicChatController with HTTP endpoints for Eino features

### Dependency Flow:

```
Handler → UseCase → Repository (Eino)
  (HTTP)    (Service)  (LLM Orchestration)
    ↓           ↓           ↓
  [Log]    [Orchestrate] [Eino Chains/Graphs]
```

### Eino Feature Implementations:

The project demonstrates the following Eino capabilities in `internal/repository/langchain/ollama/basic_chat_repo.go`:

#### 1. Basic Chat (AskBasicChat)

- Simple conversation with LLM using message history
- Demonstrates basic Generate() call with system and user messages
- Shows how to maintain conversation context

#### 2. Prompt Template (AskBasicPromptTemplateChat)

- Go template-based prompt construction
- Variable interpolation in prompts
- JSON response parsing with custom parser
- Chain composition: Template → Model → Parser

#### 3. Parallel Execution (AskBasicParallelChat)

- Concurrent execution of multiple operations
- Demonstrates Parallel component with multiple branches
- Combines LLM call with synchronous operations (string length, uppercase)
- Shows how to aggregate parallel results

#### 4. Branch Logic (AskBasicBranchChat)

- Conditional workflow branching based on input
- Dynamic prompt construction based on branch selection
- Demonstrates ChainBranch with condition function

#### 5. Tool Integration (AskWithTool)

- Integration of external tools (DuckDuckGo search)
- ToolCallingChatModel for tool-aware LLM calls
- ToolNode for tool execution
- Multi-step chain: Prompt → LLM with tools → Tool execution → Summary

#### 6. Graph Workflow (AskWithGraph)

- Node-based execution graph
- Explicit edge definitions between nodes
- Lambda nodes for custom processing
- START and END node management

#### 7. Graph with Branch (AskWithGraphWithBranch)

- Complex graph with conditional branching
- Emotion analysis with dynamic routing
- Multiple execution paths based on LLM output
- Demonstrates GraphBranch with multiple targets

### Current Implementation Details:

#### Error Handling System (pkg/errors/):

- **CustomError** struct with code, message, and error wrapping
- **Error codes** are 4-digit strings starting with '0' (e.g., "0404", "0409", "0500")
- **errors.New(code, message, err)**: Create new error with code
- **errors.Wrap(err, message, code...)**: Wrap error with context, optional code override
- **errors.GetCode(err)**: Extract error code from CustomError
- Errors propagate from Repository → UseCase → Handler
- Handler determines HTTP status from error code

#### Logging System (pkg/logger/):

- **Zerolog** for structured JSON logging
- Custom time format: YYYY/MM/DD HH:MM:SS.mmm
- **TrID (Transaction ID)** included in all logs via context
- Log levels: Debug (local/dev), Info (production)
- Logging only at Handler layer, not in UseCase or Repository
- Functions: LogInfo, LogWarn, LogError, LogDebug

#### Configuration Management (internal/config/):

- **godotenv** for .env.local file loading
- Environment variables take precedence over file values
- Required variables: PORT, ENV
- No default values for mandatory configuration (fail fast)

#### HTTP Response Format:

- **StandardResponse** struct: {trid, code, result}
- TrID always first field in JSON response
- Code: 4-digit string (HTTP status or custom error code)
- WriteStandardJSON helper with optional custom code parameter

### Key Principles:

- **Dependency Inversion**: Higher layers depend on interfaces, not implementations
- **Single Responsibility**: Each layer has a clear, focused purpose
- **Separation of Concerns**: Logging and error handling at boundaries only
- **Testability**: Each layer can be tested in isolation with mocks
- **Flexibility**: Implementations can be swapped without affecting other layers

### Development Best Practices:

- Write **short, focused functions** with a single responsibility
- Use **custom error system** (pkg/errors) with error codes:
  - Create errors: `errors.New(constants.ErrorCode, "message", underlyingErr)`
  - Wrap errors: `errors.Wrap(err, "context", optionalCode)`
  - Extract codes: `errors.GetCode(err)` to determine HTTP status
  - Error codes must be 4-digit strings starting with '0'
- Avoid **global state**; use constructor functions to inject dependencies
- Leverage **Go's context propagation** for request-scoped values (TrID), deadlines, and cancellations
- Use **TrID (Transaction ID)** via context for request tracing:
  - Generated in middleware: `middleware.TrID()`
  - Accessed via: `ctx.Value(constants.ContextKeyTrID)`
  - Included in all logs and responses
- Use **goroutines safely**; guard shared state with channels or sync primitives
- **Defer closing resources** and handle them carefully to avoid leaks
- Set **timezone to UTC** globally: `time.Local = time.UTC`
- **Logging only at handler layer**, not in usecase or repository layers

### Eino-Specific Best Practices:

- **Chain Construction**: Use NewChain() for sequential operations
- **Parallel Execution**: Use NewParallel() for concurrent operations
- **Branching**: Use Branch/GraphBranch for conditional logic
- **Tool Integration**:
  - Register tools with WithTools() on the model
  - Use ToolNode for tool execution
  - Handle tool results in subsequent chain steps
- **Graph Workflows**:
  - Define nodes explicitly with Add\*Node() methods
  - Connect nodes with AddEdge()
  - Always connect to START and END nodes
  - Use meaningful node names for debugging
- **Template Management**:
  - Use schema.GoTemplate for Go template syntax
  - Separate system and user messages
  - Validate template variables before rendering
- **Error Handling**: Wrap Eino errors with context for debugging
- **Context Propagation**: Always pass context through Eino operations

### Security and Resilience:

- Apply **input validation and sanitization** rigorously, especially on LLM inputs
- Implement **timeouts** on all LLM calls to prevent hanging requests
- Use **circuit breakers** if implementing production LLM services
- Be mindful of **rate limits** when using external LLM APIs or tools
- Validate and sanitize **LLM outputs** before using them in application logic
- Implement **prompt injection protection** for user-provided prompts

### Testing:

- Write **unit tests** using table-driven patterns and parallel execution
- **Mock external interfaces** cleanly using generated mocks (go.uber.org/mock)
- Mock the LLM model for testing Eino chains without actual API calls
- Test individual Eino components (chains, branches, tools) in isolation
- Separate **fast unit tests** from slower integration tests
- Use `make build-mocks` to regenerate mocks after interface changes
- Ensure **test coverage** for every exported function

### Documentation and Standards:

- Document public functions and packages with **GoDoc-style comments**
- Provide concise **READMEs** for services and libraries
- Document Eino chain logic with inline comments explaining the flow
- Enforce naming consistency and formatting with 'go fmt', 'goimports', and 'golangci-lint'

### Observability and Logging:

- Use **Zerolog** for structured JSON logging with custom time format
- All logs must be in **JSON format** for all environments (local, dev, production)
- Include **TrID (Transaction ID)** in all logs via context for request correlation
- Use **custom HTTP logger middleware** to log HTTP requests with TrID
- Log format: `{"level":"info","trid":"...","time":"2025/01/01 01:01:01.333","message":"..."}`
- **Log levels**:
  - Debug: development/local environments only
  - Info: successful operations, request/response tracking
  - Warn: client errors (400, 404, 409), validation failures
  - Error: server errors (500), LLM failures, unexpected errors
- **Logging strategy**:
  - Log at **handler layer only** (controllers, middleware)
  - Do NOT log in usecase or repository layers
  - Log request start, success, and all error conditions
  - Include relevant context (operation type, parameters) when available

### HTTP Middleware Stack:

1. **TrID()**: Generate and inject transaction ID into context
2. **CORS()**: Handle cross-origin requests
3. **RealIP**: Extract real client IP
4. **HTTPLogger()**: Log HTTP requests with TrID
5. **Recoverer**: Recover from panics

### DTO Mapping Strategy:

- Keep DTOs separate in `internal/handler/http/dto/`
- DTOs should be simple, serializable structures
- Controllers parse request DTOs, extract values, pass to usecase
- Usecase returns internal types, controllers transform to response DTOs
- No direct coupling between DTOs and internal types

### Performance:

- Use **benchmarks** to track performance of Eino chains
- Monitor **LLM call latency** and token usage
- Minimize **allocations** in hot paths
- Profile Eino operations to identify bottlenecks
- Consider **caching** for repeated LLM operations with same inputs

### Concurrency and Goroutines:

- Ensure safe use of **goroutines**, and guard shared state with channels or sync primitives
- Implement **goroutine cancellation** using context propagation
- Eino operations are context-aware and support cancellation
- Use Parallel component for concurrent Eino operations

### Tooling and Dependencies:

- Rely on **stable, minimal third-party libraries**; prefer the standard library where feasible
- Use **Go modules** for dependency management and reproducibility
- Version-lock dependencies for deterministic builds
- Integrate **linting, testing, and security checks** in CI pipelines

#### Core Dependencies:

- **HTTP Router**: chi (github.com/go-chi/chi/v5) - lightweight, idiomatic HTTP router
- **LLM Framework**: Cloudwego Eino (github.com/cloudwego/eino) - LLM orchestration framework
- **LLM Model**: Ollama (github.com/cloudwego/eino-ext/components/model/ollama) - local LLM inference
- **Tools**: DuckDuckGo (github.com/cloudwego/eino-ext/components/tool/duckduckgo) - web search
- **LLM Utilities**: LangChainGo (github.com/tmc/langchaingo) - additional LLM helpers
- **Logging**: zerolog (github.com/rs/zerolog) - structured JSON logging
- **Configuration**: godotenv (github.com/joho/godotenv) - .env file loading
- **Testing**: go.uber.org/mock - mock generation

#### Development Tools:

- **Makefile** for common tasks (build, test, mocks, clean)
- **mockgen** for generating mock implementations
- **golangci-lint** for code quality checks

### Key Conventions:

1. **Readability and Maintainability**:

   - Prioritize clear, simple, and maintainable code
   - Use descriptive names for functions, variables, and types
   - Keep functions short and focused on a single responsibility

2. **Architecture and Dependencies**:

   - Design for change: isolate business logic and minimize framework lock-in
   - Emphasize clear boundaries and dependency inversion
   - Dependencies flow: Handler → UseCase → Repository (Eino)
   - Interfaces defined in the layer that uses them

3. **Error Handling**:

   - Always use custom error system with 4-digit error codes
   - Error codes start with '0' and align with HTTP status codes
   - Wrap errors as they propagate through layers
   - Handler layer determines HTTP status from error codes
   - Examples: "0400" (Bad Request), "0404" (Not Found), "0500" (Internal Error)

4. **Logging Strategy**:

   - Log ONLY at handler layer (controllers, middleware)
   - Include TrID in all logs for request tracing
   - Use appropriate log levels: Debug, Info, Warn, Error
   - JSON format for all environments

5. **HTTP Response Format**:

   - All responses use StandardResponse: `{trid, code, result}`
   - TrID is always the first field in JSON
   - Code is a 4-digit string (HTTP status or custom error code)
   - Use WriteStandardJSON helper with optional custom code

6. **Configuration and Environment**:

   - Use .env.local for local development
   - Environment variables take precedence
   - No default values for required configuration (fail fast)
   - Always set timezone to UTC globally

7. **Testing and Quality**:

   - Ensure all behavior is observable, testable, and documented
   - Write unit tests with table-driven patterns
   - Mock interfaces for isolation (especially LLM models)
   - Automate workflows for testing, building, and deployment
   - Use `make build-mocks` to regenerate mocks

8. **Eino Patterns**:
   - Use Chain for sequential LLM operations
   - Use Parallel for concurrent operations
   - Use Branch for conditional logic
   - Use Graph for complex workflows
   - Always compile chains/graphs before invoking
   - Handle LLM errors gracefully with proper error wrapping

### Development Commands:

| Command            | Description                     |
| ------------------ | ------------------------------- |
| `make build`       | Build the application           |
| `make start`       | Run the built binary            |
| `make test`        | Run unit tests                  |
| `make build-mocks` | Generate mock implementations   |
| `make test-all`    | Run tests + vet + fmt + lint    |
| `make fmt`         | Format code with go fmt         |
| `make vet`         | Vet code with go vet            |
| `make lint`        | Lint code with golangci-lint    |
| `make tool`        | Install development tools       |
| `make clean`       | Clean build artifacts           |
| `make vendor`      | Vendor dependencies             |
| `make all`         | Full setup: tool + init + build |
